* Shelly (The little python shell)
  Shelly is the little python shell that could!
  
** Usage
   Shelly supports I/O redirection via
   the =<= and =>= operators.

   You can use Shelly to call executable programs found in your =$PATH=.
   #+BEGIN_SRC sh
   $ python3 ./shelly.py
   shelly $ ...
   #+END_SRC

** How it works
   In general,
   like you would expect a shell to work.
   1. Ask for a command
      1.a. Evaluate (is that the right word?) the command
   2. Execute the command!
   3. Do it again.   

*** shelly.read_()
    The =read_()= function is the bread and butter of this program.
    It gets called in an infinite loop.
    It handles parsing the user's input and
    making the appropriate call to =shelly.exec_()=.
    
    read_() uses a nice one-liner to
    create a prompt for the user and tokenize their input.
    
    A slightly wordy while loop checks the list of tokens (=args=)
    for =<= and =>=.
    It then picks out the appropriate new I/O file names to pass to =exec_()=.

*** shelly.exec_(args=[], in_redir=None, out_redir=None)
    This is the bit that actually asks the OS to run our command
    by forking a child process and calling =os.execve()=
    
    This method takes a list of args to be passed to =os.execve()=.
    The =in_redir= and =out_redir= arguments are
    filenames that will be the new I/O for the command.
    If either is non-None (that sounds funny)
    their respective file descriptor is closed and
    the new file is opened in it's place.
    The following idiom for this action is used:
    
    #+BEGIN_SRC python
    # Ex. change the stdin file descriptor w/o os.dup2()
    if in_redir:
	os.close(0)                 # redirect child's stdout
	sys.stdin = open(in_redir, "r")
	fd = sys.stdin.fileno() # os.open(in_redir, os.O_CREAT)
	os.set_inheritable(fd, True)
	os.write(2, ("Child: opened fd=%d for reading\n" % fd).encode())
    #+END_SRC
    
    There is a shorter way of saying this using
    [[https://docs.python.org/3.5/library/os.html#os.dup2][os.dup2(fd, fd2, inheritable=True)]]

    #+BEGIN_SRC python
    # Ex. change the stdin file descriptor with os.dup2()
    if in_redir:
	os.dup2(os.open(in_redir, os.O_RDONLY), 0)
	fd = sys.stdin.fileno()
	os.write(2, ("Child: opened fd=%d for reading\n" % fd).encode())
    #+END_SRC
    
    This may or may not be better/more pythonic because
    you don't get to use python's nice =open("filename", mode)= function but,
    =os.dup2= does set the fd to =inheritable= by default and,
    it will automatically close =fd= if necessary.
    The big thing is remembering to OR together the right flags.
    I'm not going to use it here
    (at least as of right now)
    for the sake of clarity.
    
    For execution,
    the program tries execution with every directory listed in 
    =os.environ['PATH']=, in the order they are listed.
    Nothing crazy here.

* Bad file descriptor error
  My code has two functions, read_() and exec_()
  read_() handles getting input from the user, and exec_() makes the call to =os.execve()=.
  
  I had a working version earlier with '<' and '>' I/O redirection 
  (see commit =692d031 Add '<' and '>' I/O redirection=)
  that had exec_() take filepaths rather than file descriptors.
  The child process was the one that would open the file and rearange it's fds.
  
  In this latest commit (=5f8d8f1 Changed run_ to pass fds to exec_=)
  I changed read_() (I wrote run_() by mistake in my commit message, sorry)
  to open the new I/O filepaths as the parent process, and then just pass the fd
  to exec_() for the child to just change it's fd. This way, when I start making pipes,
  I can create the pipe in the parent, and pass the appropriate fds for the pipes to the children.
  
  The files are being opened by the parent and set to inheritable from lines 43-52
  and the fds are being changed by the child from lines 79-92.
  
  After changing this, I started getting "Bad File Descriptor" errors from the programs I was execing.

  Test using =new_in_fd = os.open(new_in_fpath, os.O_RDONLY)= for opening the file.
  #+BEGIN_SRC sh
mk@nyarlathotep ~/src/school/operating-systems/python-warmup/shell $ python3 ./shelly.py
shelly $ wc < shelly.py
fpath: shelly.py at index: 1 fd: 3           # <--- the file was opened and I got a new fd line_no: 43-47
['wc']
Command read...About to fork (pid:25475)
Parent: My pid=25475.  Child's pid=25486
Child: My pid=25486.  Parent's pid=25475
Child: given in_fd: 3                        # <--- same fd made it to the child line_no: 79-85
Child: using fd=0 for reading                # <--- sys.stdin.fileno() returns 0
Child:  ...trying to exec /opt/wzb-utils/wc
Child:  ...trying to exec /home/mk/bin/wc
Child:  ...trying to exec /usr/local/bin/wc
Child:  ...trying to exec /usr/bin/wc
wc: 'standard input': Bad file descriptor    # <--- wc doesn't like the stdin filedescriptor
0 0 0
wc: -: Bad file descriptor
Parent: Child 25486 terminated with exit code 256
shelly $ exit
  #+END_SRC
  
  I tried opening the files differently (lines 45 and 50, presently commented out)
  using =new_in_fd = open(new_in_fpath, 'r').fileno()=, and got a different error below.
  
  #+BEGIN_SRC sh
mk@nyarlathotep ~/src/school/operating-systems/python-warmup/shell $ python3 ./shelly.py
shelly $ wc < shelly.py
Traceback (most recent call last):
  File "./shelly.py", line 114, in <module>
    read_()
  File "./shelly.py", line 46, in read_
    os.set_inheritable(new_in_fd, True)
OSError: [Errno 9] Bad file descriptor
  #+END_SRC
